<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <base target="_parent">

    <title>Metaframe Mermaid</title>
    <style>
      html,
      body {
        width: 100%;
        height: 100%;
        margin: 0px;
        border: 0;
        /* No floating content on sides */
        display: block;
        background: none transparent;
        /* background-color: blueviolet; */
      }
      .transparent {
        background: none transparent;
      }
      /* apply a natural box layout model to all elements, but allowing components to change */
      /* https://www.paulirish.com/2012/box-sizing-border-box-ftw/ */
      html {
        box-sizing: border-box;
      }
      *,
      *:before,
      *:after {
        box-sizing: inherit;
      }

      .menu-button {
        position: absolute;
        top: 10px;
        left: calc(100vw - 50px);
        z-index: 1000;
        background-color: transparent;
        border: 0px;
        padding: 0px;
        margin: 0px;
        width: 40px;
        height: 40px;
        /* background-color: red; */
      }

      .container {
        display: flex;
        width: 100vw;
        height: 100vh;
        justify-content: center;
        align-items: stretch;
        gap: 0px;
      }

      .container-with-editor {
        /* display: flex;
        flex-direction: row-reverse; */
        width: 100vw;
        height: 100vh;
        /* justify-content: flex-start;
        align-items: stretch;
        gap: 0px; */
      }

      .root {
        width: 100%;
        max-width: 100%;
      }

      .root-with-editor {
        position: absolute;
        top: 60px;
        /* left: 50%; */
        width: 100%;
        max-width: 100%;
        height: calc(100vh - 60px);
        max-height: calc(100vh - 60px);
      }

      @media only screen and (min-width: 1000px) {
        .root-with-editor {
          position: absolute;
          top: 60px;
          left: 50%;
          width: 50%;
          max-width: 50%;
          height: calc(100vh - 60px);
          max-height: calc(100vh - 60px);
        }
      }

      /* .root-with-editor {
        position: absolute;
        top: 60px;
        left: 50%;
        width: 50%;
        max-width: 50%;
        height: calc(100vh - 60px);
        max-height: calc(100vh - 60px);
      } */

      /**
       * Special handling of iframes for ensuring the metaframe is correctly maximized.
       */

      .iframe-container {
        position: absolute;
        width: 100%;
        min-width: 100%;
      }

      .iframe-container iframe {
        overflow: hidden;
        border: 0;
        min-height: 100vh;
        max-height: 100%;
        left: 0;
        position: absolute;
        top: 0;
      }
      iframe {
        width: 100%;
      }

      /* Base style for <pre> blocks */
      .pre-stdout {
        background-color: #f8f8f8; /* light grey background */
        /* border: 1px solid #ccc; light grey border */
        border-left: 3px solid #000; /* teal accent on the left */
        /* padding: 10px; */
        overflow: auto; /* in case of overflow */
        font-family: "Courier New", Courier, monospace; /* monospaced font */
        white-space: pre-wrap; /* wrap white-space */
        word-wrap: break-word; /* break long words */
        margin: 0px;
      }

      /* Style for stderr to make it stand out */
      .pre-stderr {
        background-color: #fff0f0; /* light red background */
        /* border: 1px solid #ffcccc; light red border */
        border-left: 3px solid #e53935; /* darker red accent on the left */
        color: #d32f2f; /* darker red text color */
        /* padding: 10px; */
        overflow: auto; /* in case of overflow */
        font-family: "Courier New", Courier, monospace; /* monospaced font */
        white-space: pre-wrap; /* wrap white-space */
        word-wrap: break-word; /* break long words */
        margin: 0px;
      }

      /* .borderFatSolidGreen {
        border: 5px solid green;
      }

      .borderDashedPurple {
        border: 4px dashed purple;
      }

      .borderDashedRed {
        border: 2px dashed red;
      }

      .borderDashedBlue {
        border: 2px dashed blue;
      } */

      .invisible-until-hover {
        opacity: 0; /* Make the element fully transparent initially */
        transition: opacity 0.3s; /* Optional: Smooth transition for the opacity change */
      }

      .invisible-until-hover:hover {
        opacity: 1; /* Make the element fully opaque (visible) when hovered */
      }
    </style>
    <!-- <script src=" https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js "></script> -->

    <script type="module">
      import mermaid from "https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.esm.min.mjs";
      mermaid.initialize({
        startOnLoad: false,
        securityLevel: "loose",
        flowchart: {
          useMaxWidth: false,
          htmlLabels: false,
        },
      });
      window.mermaid = mermaid;
    </script>

    <!-- Misc generic and specific functions -->
    <script>

      const isEditMode = !!(new URL(window.location.href).searchParams.get("edit"));

      window.logStdout = (s) => {
        const root = document.getElementById("root");
        const pre = document.createElement("pre");
        pre.textContent = s;
        pre.className = "pre-stdout";
        root.appendChild(pre);
        root.scrollTop = root.scrollHeight;
      };
      window.log = logStdout;

      window.logStderr = (s) => {
        const root = document.getElementById("root");
        const pre = document.createElement("pre");
        pre.textContent = s;
        pre.className = "pre-stderr";
        root.appendChild(pre);
        root.scrollTop = root.scrollHeight;
      };

      const safe = (s) => {
        return s.replace(/-/g, "_");
      };

      // returns { mermaid?: string; error?: string[] }
      const createMermaidFlowchartFromMetapage = (metapageDefinition) => {
        if (!metapageDefinition) {
          return {
            error: [
              `Metapage definition: cannot graph: metapageDefinition is null`,
            ],
          };
        }

        if (typeof metapageDefinition === "string") {
          // maybe it is a JSON string
          try {
            metapageDefinition = JSON.parse(metapageDefinition);
          } catch (err) {
            // guess not
            return {
              error: [
                `Metapage definition: failed to JSON.parse metapageDefinition: ${metapageDefinition}`,
                `${err}`,
              ],
            };
          }
        }

        if (!metapageDefinition.metaframes) {
          return {
            error: [
              `Metapage definition: Cannot graph, no metaframes: ${metapageDefinition}`,
            ],
          };
        }

        let graphDefinition = "flowchart LR";
        const metaframeKeys = Object.keys(metapageDefinition.metaframes);
        const metaframeKeysToMermaidId = Object.fromEntries(
          Object.entries(metapageDefinition.metaframes).map(([k, v], i) => [
            k,
            `m${i + 1}`,
          ])
        );

        metaframeKeys.forEach(function (metaframeId, index) {
          graphDefinition += `\n\t${metaframeKeysToMermaidId[metaframeId]}["${metaframeId}"]`;
          graphDefinition += `\n\tclick ${metaframeKeysToMermaidId[metaframeId]} handleClick`;
        });
        metaframeKeys.forEach(function (metaframeId, index) {
          if (
            metapageDefinition.metaframes[metaframeId].inputs &&
            Object.keys(metapageDefinition.metaframes[metaframeId].inputs)
              .length > 0
          ) {
            metapageDefinition.metaframes[metaframeId].inputs.forEach(
              // MetaframeInputMap
              (pipe) => {
                if (!metaframeKeysToMermaidId[pipe.metaframe]) {
                  return;
                }

                if (pipe.target) {
                  graphDefinition += `\n\t${
                    metaframeKeysToMermaidId[pipe.metaframe]
                  }-- ${safe(pipe.source)}:${safe(pipe.target)} -->${
                    metaframeKeysToMermaidId[metaframeId]
                  }`;
                } else {
                  graphDefinition += `\n\t${
                    metaframeKeysToMermaidId[pipe.metaframe]
                  }-- ${safe(pipe.source)} -->${
                    metaframeKeysToMermaidId[metaframeId]
                  }`;
                }
              }
            );
          }
        });

        graphDefinition += "\n";

        return { mermaid: graphDefinition };
      };
    </script>

    <!-- Manually converted ts-js from https://github.com/metapages/hash-query/blob/main/src/lib/util.ts -->
    <script>
      const isIframe = () => {
        //http://stackoverflow.com/questions/326069/how-to-identify-if-a-webpage-is-being-loaded-inside-an-iframe-or-directly-into-t
        try {
          return window !== window.top;
        } catch (ignored) {
          return false;
        }
      };

      const blobToBase64String = (blob) => {
        return btoa(encodeURIComponent(JSON.stringify(blob)));
      };

      const blobFromBase64String = (value) => {
        if (value && value.length > 0) {
          const blob = JSON.parse(decodeURIComponent(atob(value)));
          return blob;
        }
        return undefined;
      };

      // Get everything after # then after ?
      const getUrlHashParams = (url) => {
        const urlBlob = new URL(url);
        return getUrlHashParamsFromHashString(urlBlob.hash);
      };

      const getUrlHashParamsFromHashString = (hash) => {
        let hashString = hash;
        while (hashString.startsWith("#")) {
          hashString = hashString.substring(1);
        }

        const queryIndex = hashString.indexOf("?");
        if (queryIndex === -1) {
          return [hashString, {}];
        }
        const preHashString = hashString.substring(0, queryIndex);
        hashString = hashString.substring(queryIndex + 1);
        const hashObject = {};
        hashString
          .split("&")
          .filter((s) => s.length > 0)
          .map((s) => {
            const dividerIndex = s.indexOf("=");
            if (dividerIndex === -1) {
              return [s, ""];
            }
            const key = s.substring(0, dividerIndex);
            const value = s.substring(dividerIndex + 1);
            return [key, value];
          })
          .forEach(([key, value]) => {
            hashObject[key] = value;
          });

        Object.keys(hashObject).forEach((key) => {
          try {
            hashObject[key] = decodeURI(hashObject[key]);
          } catch (ignored) {
            hashObject[key] = hashObject[key];
          }
        });
        return [preHashString, hashObject];
      };

      const getHashParamValue = (url, key) => {
        const [_, hashParams] = getUrlHashParams(url);
        return hashParams[key];
      };

      const getHashParamValueJson = (url, key) => {
        const valueString = getHashParamValue(url, key);
        if (valueString && valueString !== "") {
          const value = blobFromBase64String(valueString);
          return value;
        }
        return;
      };

      const getHashParamFromWindow = (key) => {
        return getHashParamsFromWindow()[1][key];
      };

      const getHashParamsFromWindow = () => {
        return getUrlHashParams(window.location.href);
      };

      const getHashParamValueDecodedBase64FromWindow = (key) => {
        return getHashParamValueDecodedBase64(window.location.href, key);
      };

      const getHashParamValueJsonFromWindow = (key) => {
        return getHashParamValueJson(window.location.href, key);
      };

      const getHashParamValueDecodedBase64 = (url, key) => {
        const valueString = getHashParamValue(url, key);
        if (valueString && valueString !== "") {
          const value = atob(valueString);
          return value;
        }
        return;
      };

      const setHashParamInWindow = (key, value, opts) => {
        const hash = window.location.hash.startsWith("#")
          ? window.location.hash.substring(1)
          : window.location.hash;
        const newHash = setHashValueInHashString(hash, key, value);
        if (newHash === hash) {
          return;
        }

        if (opts?.modifyHistory) {
          // adds to browser history, so affects back button
          // fires "hashchange" event
          window.location.hash = newHash;
        } else {
          // The following will NOT work to trigger a 'hashchange' event:
          // Replace the state so the back button works correctly
          window.history.replaceState(
            null,
            document.title,
            `${window.location.pathname}${window.location.search}${
              newHash.startsWith("#") ? "" : "#"
            }${newHash}`
          );
          // Manually trigger a hashchange event:
          // I don't know how to add the previous and new url parameters
          window.dispatchEvent(new HashChangeEvent("hashchange"));
        }
      };

      const setHashParamJsonInWindow = (key, value, opts) => {
        const valueString = value ? blobToBase64String(value) : undefined;
        setHashParamInWindow(key, valueString, opts);
      };

      // returns hash string
      const setHashValueInHashString = (hash, key, value) => {
        const [preHashParamString, hashObject] =
          getUrlHashParamsFromHashString(hash);

        let changed = false;
        if (
          (hashObject.hasOwnProperty(key) && value === null) ||
          value === undefined
        ) {
          delete hashObject[key];
          changed = true;
        } else {
          if (hashObject[key] !== value) {
            hashObject[key] = value;
            changed = true;
          }
        }

        // don't do work if unneeded
        if (!changed) {
          return hash;
        }

        const keys = Object.keys(hashObject);
        keys.sort();
        const hashStringNew = keys
          .map((key, i) => {
            return `${key}=${encodeURI(hashObject[key])}`;
          })
          .join("&");
        // replace after the ? but keep before that
        return `${preHashParamString}?${hashStringNew}`;
      };

      const setHashValueJsonInHashString = (hash, key, value) => {
        const valueString = value ? blobToBase64String(value) : undefined;
        return setHashValueInHashString(hash, key, valueString);
      };

      // returns URL string
      const setHashValueInUrl = (url, key, value) => {
        const urlBlob = new URL(url);
        const newHash = setHashValueInHashString(urlBlob.hash, key, value);
        urlBlob.hash = newHash;
        return urlBlob.href;
      };

      // returns URL string
      const setHashValueJsonInUrl = (url, key, value) => {
        const urlBlob = new URL(url);
        urlBlob.hash = setHashValueJsonInHashString(urlBlob.hash, key, value);
        return urlBlob.href;
      };
    </script>

    <script>
      const refreshUpdateSvgButton = () => {
        // only show the edit button if we are NOT in an iframe
        // or explicitly edit=true is in the hash params
        // this will be turned into a configurable option later, but no time rn
        const [_, hashParams] = getUrlHashParamsFromHashString(
          window.location.hash
        );
        

        if (isEditMode) {
          // do NOT change the visibility of the edit buttons
          return;
        }

        if (hashParams["hm"] === "disabled") {
          document.getElementById("menu-button").style.display = "none";
        } else if (hashParams["hm"] === "invisible") {
          // default
          document
            .getElementById("svgiconinstance")
            .classList.add("invisible-until-hover");
        } else if (hashParams["hm"] === "visible") {
          // visible, so leave alone
        } else {
          // default is invisible but clickable for iframe apps, and visible for non-iframe apps
          if (isIframe()) {
            document
              .getElementById("svgiconinstance")
              .classList.add("invisible-until-hover");
          }
        }
      };

      const getQueryParamValueJsonFromWindow = (key) => {
        const url = new URL(window.location.href);
        const valueString = url.searchParams.get(key);

        if (valueString && valueString !== "") {
          const value = blobFromBase64String(valueString);
          return value;
        }
        return;
      };

      const stringFromBase64String = (value) => {
        if (value && value.length > 0) {
          try {
            return decodeURIComponent(atob(value));
          } catch (err) {
            console.error(err);
            try {
              return atob(value);
            } catch (err) {
              console.error(err);
              return undefined;
            }
          }
        }
        return undefined;
      };

      const getCodeFromUrl = () => {
        const [prefix, hashParams] = getUrlHashParamsFromHashString(
          window.location.hash
        );
        let jsFromUrl = hashParams?.text;

        // expecting js code via hash params, but that fails to embed in some places e.g. notion
        // so also allow js from query params if none in hash params
        if (!jsFromUrl) {
          jsFromUrl = new URL(window.location.href).searchParams.get("text");
        }

        if (jsFromUrl) {
          jsFromUrl = stringFromBase64String(jsFromUrl);
        }

        return jsFromUrl;
      };

      const setJsInUrl = (js) => {
        setHashParamInWindow("text", stringToBase64String(js));
      };

      const runCode = async (code) => {
        // clear all children of root (only can be there from user code)
        document.getElementById("root").innerHTML = "";
        if (!code) {
          return;
        }

        try {
          let { svg, bindFunctions } = await mermaid.render(
            `randomId${Math.floor(Math.random() * 10000000)}`,
            code
          );

          if (!svg) {
            return;
          }

          document.getElementById("root").innerHTML = svg;
        } catch (err) {
          // console.error(err.message);
          // guess not
          logStderr(err);
        }
      };

      const runCodeFromUrl = async () => {
        let mermaidDefinition = getCodeFromUrl();
        await runCode(mermaidDefinition);
      };
    </script>
    <script type="module">
      import {
        Metapage,
        Metaframe,
      } from "https://cdn.jsdelivr.net/npm/@metapages/metapage@0.13.10-alpha1/dist/index.mjs";

      // Examine URL, and add modules
      window.metapage = {
        Metapage,
        Metaframe,
      };

      if (!window.metaframe) {
        window.metaframe = new Metaframe();
      }
      var metaframe = window.metaframe;

      // document.addEventListener("DOMContentLoaded", runCodeFromUrl);
      window.addEventListener("load", runCodeFromUrl);
      // reload on hash changes
      window.addEventListener("hashchange", runCodeFromUrl, false);

      // mermaid specific: show metapage diagrams if they are inputs
      const onInputs = (inputs) => {
        if (inputs["metapage/definition"]) {
          const { mermaid, error } = createMermaidFlowchartFromMetapage(
            inputs["metapage/definition"]
          );
          runCode(mermaid || "");
          logStderr(error?.message);
        } else if (inputs["mermaid"]) {
          runCode(inputs["mermaid"]);
        }
      };
      metaframe.addListener(window.metapage.Metapage.INPUTS, onInputs);
    </script>
  </head>
  <body>
    <button id="menu-button" class="btn-highlight btn-icon menu-button">
      <div id="toggle-icon-container" class="svgicon">
        <svg
          id="svgiconinstance"
          height="24"
          viewBox="0 0 24 24"
          width="24"
          xmlns="http://www.w3.org/2000/svg"
        >
          <path d="m0 0h24v24h-24z" fill="none" />
          <path
            d="m3 17.46v3.04c0 .28.22.5.5.5h3.04c.13 0 .26-.05.35-.15l10.92-10.91-3.75-3.75-10.91 10.91c-.1.1-.15.22-.15.36zm17.71-10.42c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75z"
          />
        </svg>
      </div>
    </button>
    <script>
      const metapageDef = {
        metaframes: {
          editor: {
            url: `${window.location.origin}/editor/#?c=eyJtb2R1bGVzIjpbXX0=`,
          },
        },
        version: "0.3",
      };

      const onMenuClick = async () => {
        // if there is an existing editor, remove it, then exit
        if (document.getElementById("iframe-container")) {
          if (window.metapageEditor) {
            window.metapageEditor.dispose();
            window.metapageEditor = null;
          }
          const previousContainer = document.getElementById("iframe-container");
          if (previousContainer) {
            previousContainer.parentElement.removeChild(previousContainer);
          }
          document.getElementById(
            "toggle-icon-container"
          ).innerHTML = `<svg id="svgiconinstance" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="m0 0h24v24h-24z" fill="none"/><path d="m3 17.46v3.04c0 .28.22.5.5.5h3.04c.13 0 .26-.05.35-.15l10.92-10.91-3.75-3.75-10.91 10.91c-.1.1-.15.22-.15.36zm17.71-10.42c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75z"/></svg>`;
          refreshUpdateSvgButton();
          document.getElementById("root").className =
            "root borderFatSolidGreen";
          document.getElementById("container").className =
            "container borderDashedBlue";
          // console.log("found, removing/toggling OFF");
          runCodeFromUrl();

          return;
        }

        document.getElementById(
          "toggle-icon-container"
        ).innerHTML = `<svg style="fill: green; stroke: green;" height="24" width="24" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><path d="m173.898 439.404-166.4-166.4c-9.997-9.997-9.997-26.206 0-36.204l36.203-36.204c9.997-9.998 26.207-9.998 36.204 0l112.095 112.094 240.095-240.094c9.997-9.997 26.207-9.997 36.204 0l36.203 36.204c9.997 9.997 9.997 26.206 0 36.204l-294.4 294.401c-9.998 9.997-26.207 9.997-36.204-.001z"/></svg>`;

        // no previous editor detected, add the editor metapage
        // listen to the editor metapage for changes to the editor url hash
        // and make that our own url hash
        document.getElementById("root").className =
          "root-with-editor borderFatSolidGreen";
        document.getElementById("container").className =
          "container-with-editor borderDashedBlue";

        // Modify the metapage editor url hash to our own
        const editorUrl = new URL(metapageDef.metaframes.editor.url);
        editorUrl.hash = window.location.hash;
        metapageDef.metaframes.editor.url = editorUrl.href;

        const mp = window.metapage.Metapage.from(metapageDef);
        window.metapageEditor = mp;
        const editorMetaframe = mp.getMetaframe("editor");
        const iframe = await editorMetaframe.iframe;

        var iframeDivContainer = document.createElement("div");
        iframeDivContainer.id = "iframe-container";
        iframeDivContainer.className = "iframe-container";
        iframeDivContainer.appendChild(iframe);

        document.getElementById("container").append(iframeDivContainer);
        runCodeFromUrl();

        let pending;
        const updateCode = (hash) => {
          if (pending) {
            clearTimeout(pending);
          }
          pending = setTimeout(() => {
            pending = null;
            window.location.hash = hash;
          }, 400);
        };
        mp.addListener(window.metapage.Metapage.DEFINITION, (event) => {
          const url = event?.definition?.metaframes?.editor?.url;
          if (url) {
            const urlBlob = new URL(url);
            const newHash = urlBlob.hash;
            updateCode(newHash);
          }
        });

        // mermaid click handler
        window.handleClick = (nodeClickText) => {
          mp.setOutput("click", nodeClickText);
        };
      };

      document
        .getElementById("menu-button")
        .addEventListener("click", onMenuClick);

      refreshUpdateSvgButton();
      if (isEditMode) {
        // if editing, force showing the menu
        window.addEventListener("load", () => {
          onMenuClick();
        });
      }
      // }
    </script>

    <div id="container" class="container borderDashedPurple transparent">
      <div id="root" class="root borderFatSolidGreen transparent"></div>
    </div>
  </body>
</html>
